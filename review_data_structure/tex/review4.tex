% 若编译失败，且生成 .synctex(busy) 辅助文件，可能有两个原因：
% 1. 需要插入的图片不存在：Ctrl + F 搜索 'figure' 将这些代码注释/删除掉即可
% 2. 路径/文件名含中文或空格：更改路径/文件名即可

% ------------------------------------------------------------- %
% >> ------------------ 文章宏包及相关设置 ------------------ << %
% 设定文章类型与编码格式
\documentclass[UTF8]{report}		

% 本文特殊宏包
\usepackage{siunitx} % 埃米单位

% 本 .tex 专属的宏定义
    \def\V{\ \mathrm{V}}
    \def\mV{\ \mathrm{mV}}
    \def\kV{\ \mathrm{KV}}
    \def\KV{\ \mathrm{KV}}
    \def\MV{\ \mathrm{MV}}
    \def\A{\ \mathrm{A}}
    \def\mA{\ \mathrm{mA}}
    \def\kA{\ \mathrm{KA}}
    \def\KA{\ \mathrm{KA}}
    \def\MA{\ \mathrm{MA}}
    \def\O{\ \Omega}
    \def\mO{\ \Omega}
    \def\kO{\ \mathrm{K}\Omega}
    \def\KO{\ \mathrm{K}\Omega}
    \def\MO{\ \mathrm{M}\Omega}
    \def\Hz{\ \mathrm{Hz}}

% 自定义宏定义
    \def\N{\mathbb{N}}
    \def\F{\mathbb{F}}
    \def\Z{\mathbb{Z}}
    \def\Q{\mathbb{Q}}
    \def\R{\mathbb{R}}
    \def\C{\mathbb{C}}
    \def\T{\mathbb{T}}
    \def\S{\mathbb{S}}
    \def\A{\mathbb{A}}
    \def\I{\mathscr{I}}
    \def\Im{\mathrm{Im\,}}
    \def\Re{\mathrm{Re\,}}
    \def\d{\mathrm{d}}
    \def\p{\partial}

% 导入基本宏包
    \usepackage[UTF8]{ctex}     % 设置文档为中文语言
    \usepackage[colorlinks, linkcolor=blue, anchorcolor=blue, citecolor=blue, urlcolor=blue]{hyperref}  % 宏包：自动生成超链接 (此宏包与标题中的数学环境冲突)
    % \usepackage{hyperref}  % 宏包：自动生成超链接 (此宏包与标题中的数学环境冲突)
    % \hypersetup{
    %     colorlinks=true,    % false:边框链接 ; true:彩色链接
    %     citecolor={blue},    % 文献引用颜色
    %     linkcolor={blue},   % 目录 (我们在目录处单独设置)，公式，图表，脚注等内部链接颜色
    %     urlcolor={orange},    % 网页 URL 链接颜色，包括 \href 中的 text
    %     % cyan 浅蓝色 
    %     % magenta 洋红色
    %     % yellow 黄色
    %     % black 黑色
    %     % white 白色
    %     % red 红色
    %     % green 绿色
    %     % blue 蓝色
    %     % gray 灰色
    %     % darkgray 深灰色
    %     % lightgray 浅灰色
    %     % brown 棕色
    %     % lime 石灰色
    %     % olive 橄榄色
    %     % orange 橙色
    %     % pink 粉红色
    %     % purple 紫色
    %     % teal 蓝绿色
    %     % violet 紫罗兰色
    % }

    % \usepackage{docmute}    % 宏包：子文件导入时自动去除导言区，用于主/子文件的写作方式，\include{./51单片机笔记}即可。注：启用此宏包会导致.tex文件capacity受限。
    \usepackage{amsmath}    % 宏包：数学公式
    \usepackage{mathrsfs}   % 宏包：提供更多数学符号
    \usepackage{amssymb}    % 宏包：提供更多数学符号
    \usepackage{pifont}     % 宏包：提供了特殊符号和字体
    \usepackage{extarrows}  % 宏包：更多箭头符号
    \usepackage{multicol}   % 宏包：支持多栏 
    \usepackage{graphicx}   % 宏包：插入图片
    \usepackage{float}      % 宏包：设置图片浮动位置
    %\usepackage{article}    % 宏包：使文本排版更加优美
    \usepackage{tikz}       % 宏包：绘图工具
    %\usepackage{pgfplots}   % 宏包：绘图工具
    \usepackage{enumerate}  % 宏包：列表环境设置
    \usepackage{enumitem}   % 宏包：列表环境设置

% 文章页面margin设置
    \usepackage[a4paper]{geometry}
        \geometry{top=1in}
        \geometry{bottom=1in}
        \geometry{left=0.75in}
        \geometry{right=0.75in}   % 设置上下左右页边距
        \geometry{marginparwidth=1.75cm}    % 设置边注距离（注释、标记等）

% 定义 solution 环境
\usepackage{amsthm}
\newtheorem{solution}{Solution}
        \geometry{bottom=1in}
        \geometry{left=0.75in}
        \geometry{right=0.75in}   % 设置上下左右页边距
        \geometry{marginparwidth=1.75cm}    % 设置边注距离（注释、标记等）

% 配置数学环境
    \usepackage{amsthm} % 宏包：数学环境配置
    % theorem-line 环境自定义
        \newtheoremstyle{MyLineTheoremStyle}% <name>
            {11pt}% <space above>
            {11pt}% <space below>
            {}% <body font> 使用默认正文字体
            {}% <indent amount>
            {\bfseries}% <theorem head font> 设置标题项为加粗
            {：}% <punctuation after theorem head>
            {.5em}% <space after theorem head>
            {\textbf{#1}\thmnumber{#2}\ \ (\,\textbf{#3}\,)}% 设置标题内容顺序
        \theoremstyle{MyLineTheoremStyle} % 应用自定义的定理样式
        \newtheorem{LineTheorem}{Theorem.\,}
    % theorem-block 环境自定义
        \newtheoremstyle{MyBlockTheoremStyle}% <name>
            {11pt}% <space above>
            {11pt}% <space below>
            {}% <body font> 使用默认正文字体
            {}% <indent amount>
            {\bfseries}% <theorem head font> 设置标题项为加粗
            {：\\ \indent}% <punctuation after theorem head>
            {.5em}% <space after theorem head>
            {\textbf{#1}\thmnumber{#2}\ \ (\,\textbf{#3}\,)}% 设置标题内容顺序
        \theoremstyle{MyBlockTheoremStyle} % 应用自定义的定理样式
        \newtheorem{BlockTheorem}[LineTheorem]{Theorem.\,} % 使用 LineTheorem 的计数器
    % definition 环境自定义
        \newtheoremstyle{MySubsubsectionStyle}% <name>
            {11pt}% <space above>
            {11pt}% <space below>
            {}% <body font> 使用默认正文字体
            {}% <indent amount>
            {\bfseries}% <theorem head font> 设置标题项为加粗
           % {：\\ \indent}% <punctuation after theorem head>
            {\\\indent}
            {0pt}% <space after theorem head>
            {\textbf{#3}}% 设置标题内容顺序
        \theoremstyle{MySubsubsectionStyle} % 应用自定义的定理样式
        \newtheorem{definition}{}

%宏包：有色文本框（proof环境）及其设置
    \usepackage[dvipsnames,svgnames]{xcolor}    %设置插入的文本框颜色
    \usepackage[strict]{changepage}     % 提供一个 adjustwidth 环境
    \usepackage{framed}     % 实现方框效果
        \definecolor{graybox_color}{rgb}{0.95,0.95,0.96} % 文本框颜色。修改此行中的 rgb 数值即可改变方框纹颜色，具体颜色的rgb数值可以在网站https://colordrop.io/ 中获得。（截止目前的尝试还没有成功过，感觉单位不一样）（找到喜欢的颜色，点击下方的小眼睛，找到rgb值，复制修改即可）
        \newenvironment{graybox}{%
        \def\FrameCommand{%
        \hspace{1pt}%
        {\color{gray}\small \vrule width 2pt}%
        {\color{graybox_color}\vrule width 4pt}%
        \colorbox{graybox_color}%
        }%
        \MakeFramed{\advance\hsize-\width\FrameRestore}%
        \noindent\hspace{-4.55pt}% disable indenting first paragraph
        \begin{adjustwidth}{}{7pt}%
        \vspace{2pt}\vspace{2pt}%
        }
        {%
        \vspace{2pt}\end{adjustwidth}\endMakeFramed%
        }



% 外源代码插入设置
    % matlab 代码插入设置
    \usepackage{matlab-prettifier}
        \lstset{style=Matlab-editor}    % 继承 matlab 代码高亮 , 此行不能删去
    \usepackage[most]{tcolorbox} % 引入tcolorbox包 
    \usepackage{listings} % 引入listings包
        \tcbuselibrary{listings, skins, breakable}
        \newfontfamily\codefont{Consolas} % 定义需要的 codefont 字体
        \lstdefinestyle{MatlabStyle_inc}{   % 插入代码的样式
            language=Matlab,
            basicstyle=\small\ttfamily\codefont,    % ttfamily 确保等宽 
            breakatwhitespace=false,
            breaklines=true,
            captionpos=b,
            keepspaces=true,
            numbers=left,
            numbersep=15pt,
            showspaces=false,
            showstringspaces=false,
            showtabs=false,
            tabsize=2,
            xleftmargin=15pt,   % 左边距
            %frame=single, % single 为包围式单线框
            frame=shadowbox,    % shadowbox 为带阴影包围式单线框效果
            %escapeinside=``,   % 允许在代码块中使用 LaTeX 命令 (此行无用)
            %frameround=tttt,    % tttt 表示四个角都是圆角
            framextopmargin=0pt,    % 边框上边距
            framexbottommargin=0pt, % 边框下边距
            framexleftmargin=5pt,   % 边框左边距
            framexrightmargin=5pt,  % 边框右边距
            rulesepcolor=\color{red!20!green!20!blue!20}, % 阴影框颜色设置
            %backgroundcolor=\color{blue!10}, % 背景颜色
        }
        \lstdefinestyle{MatlabStyle_src}{   % 插入代码的样式
            language=Matlab,
            basicstyle=\small\ttfamily\codefont,    % ttfamily 确保等宽 
            breakatwhitespace=false,
            breaklines=true,
            captionpos=b,
            keepspaces=true,
            numbers=left,
            numbersep=15pt,
            showspaces=false,
            showstringspaces=false,
            showtabs=false,
            tabsize=2,
        }
        \newtcblisting{matlablisting}{
            %arc=2pt,        % 圆角半径
            % 调整代码在 listing 中的位置以和引入文件时的格式相同
            top=0pt,
            bottom=0pt,
            left=-5pt,
            right=-5pt,
            listing only,   % 此句不能删去
            listing style=MatlabStyle_src,
            breakable,
            colback=white,   % 选一个合适的颜色
            colframe=black!0,   % 感叹号后跟不透明度 (为 0 时完全透明)
        }
        \lstset{
            style=MatlabStyle_inc,
        }



% table 支持
    \usepackage{booktabs}   % 宏包：三线表
    %\usepackage{tabularray} % 宏包：表格排版
    %\usepackage{longtable}  % 宏包：长表格
    %\usepackage[longtable]{multirow} % 宏包：multi 行列


% figure 设置
\usepackage{graphicx}   % 支持 jpg, png, eps, pdf 图片 
\usepackage{float}      % 支持 H 选项
\usepackage{svg}        % 支持 svg 图片
\usepackage{subcaption} % 支持子图
\svgsetup{
        % 指向 inkscape.exe 的路径
       inkscapeexe = C:/aa_MySame/inkscape/bin/inkscape.exe, 
        % 一定程度上修复导入后图片文字溢出几何图形的问题
       inkscapelatex = false                 
   }

% 图表进阶设置
    \usepackage{caption}    % 图注、表注
        \captionsetup[figure]{name=图}  
        \captionsetup[table]{name=表}
        \captionsetup{
            labelfont=bf, % 设置标签为粗体
            textfont=bf,  % 设置文本为粗体
            font=small  
        }
    \usepackage{float}     % 图表位置浮动设置 
        % \floatstyle{plaintop} % 设置表格标题在表格上方
        % \restylefloat{table}  % 应用设置


% 圆圈序号自定义
    \newcommand*\circled[1]{\tikz[baseline=(char.base)]{\node[shape=circle,draw,inner sep=0.8pt, line width = 0.03em] (char) {\small \bfseries #1};}}   % TikZ solution


% 列表设置
    \usepackage{enumitem}   % 宏包：列表环境设置
        \setlist[enumerate]{
            label=\bfseries(\arabic*) ,   % 设置序号样式为加粗的 (1) (2) (3)
            ref=\arabic*, % 如果需要引用列表项，这将决定引用格式（这里仍然使用数字）
            itemsep=0pt, parsep=0pt, topsep=0pt, partopsep=0pt, leftmargin=3.5em} 
        \setlist[itemize]{itemsep=0pt, parsep=0pt, topsep=0pt, partopsep=0pt, leftmargin=3.5em}
        \newlist{circledenum}{enumerate}{1} % 创建一个新的枚举环境  
        \setlist[circledenum,1]{  
            label=\protect\circled{\arabic*}, % 使用 \arabic* 来获取当前枚举计数器的值，并用 \circled 包装它  
            ref=\arabic*, % 如果需要引用列表项，这将决定引用格式（这里仍然使用数字）
            itemsep=0pt, parsep=0pt, topsep=0pt, partopsep=0pt, leftmargin=3.5em
        }  

% 文章默认字体设置
    \usepackage{fontspec}   % 宏包：字体设置
        \setmainfont{STKaiti}    % 设置中文字体为宋体字体
        \setCJKmainfont[AutoFakeBold=3]{STKaiti} % 设置加粗字体为 STKaiti 族，AutoFakeBold 可以调整字体粗细
        \setmainfont{Times New Roman} % 设置英文字体为Times New Roman


% 其它设置
    % 脚注设置
    \renewcommand\thefootnote{\ding{\numexpr171+\value{footnote}}}
    % 参考文献引用设置
        \bibliographystyle{unsrt}   % 设置参考文献引用格式为unsrt
        \newcommand{\upcite}[1]{\textsuperscript{\cite{#1}}}     % 自定义上角标式引用
    % 文章序言设置
        \newcommand{\cnabstractname}{序言}
        \newenvironment{cnabstract}{%
            \par\Large
            \noindent\mbox{}\hfill{\bfseries \cnabstractname}\hfill\mbox{}\par
            \vskip 2.5ex
            }{\par\vskip 2.5ex}


% 各级标题自定义设置
    \usepackage{titlesec}   
    % chapter
        \titleformat{\chapter}[hang]{\normalfont\Large\bfseries\centering}{题目}{10pt}{}
        \titlespacing*{\chapter}{0pt}{-30pt}{10pt} % 控制上方空白的大小
    % section
        \titleformat{\section}[hang]{\normalfont\large\bfseries}{\thesection}{8pt}{}
    % subsection
        %\titleformat{\subsubsection}[hang]{\normalfont\bfseries}{}{8pt}{}
    % subsubsection
        %\titleformat{\subsubsection}[hang]{\normalfont\bfseries}{}{8pt}{}

% 见到的一个有意思的对于公式中符号的彩色解释的环境
        \usepackage[dvipsnames]{xcolor}
        \usepackage{tikz}
        \usetikzlibrary{backgrounds}
        \usetikzlibrary{arrows,shapes}
        \usetikzlibrary{tikzmark}
        \usetikzlibrary{calc}
        
        \usepackage{amsmath}
        \usepackage{amsthm}
        \usepackage{amssymb}
        \usepackage{mathtools, nccmath}
        \usepackage{wrapfig}
        \usepackage{comment}
        
        % To generate dummy text
        \usepackage{blindtext}
        
        
        %color
        %\usepackage[dvipsnames]{xcolor}
        % \usepackage{xcolor}
        
        
        %\usepackage[pdftex]{graphicx}
        \usepackage{graphicx}
        % declare the path(s) for graphic files
        %\graphicspath{{../Figures/}}
        
        % extensions so you won't have to specify these with
        % every instance of \includegraphics
        % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
        
        % for custom commands
        \usepackage{xspace}
        
        % table alignment
        \usepackage{array}
        \usepackage{ragged2e}
        \newcolumntype{P}[1]{>{\RaggedRight\hspace{0pt}}p{#1}}
        \newcolumntype{X}[1]{>{\RaggedRight\hspace*{0pt}}p{#1}}
        
        % color box
        \usepackage{tcolorbox}
        
        
        % for tikz
        \usepackage{tikz}
        %\usetikzlibrary{trees}
        \usetikzlibrary{arrows,shapes,positioning,shadows,trees,mindmap}
        % \usepackage{forest}
        \usepackage[edges]{forest}
        \usetikzlibrary{arrows.meta}
        \colorlet{linecol}{black!75}
        \usepackage{xkcdcolors} % xkcd colors
        
        
        % for colorful equation
        \usepackage{tikz}
        \usetikzlibrary{backgrounds}
        \usetikzlibrary{arrows,shapes}
        \usetikzlibrary{tikzmark}
        \usetikzlibrary{calc}
        % Commands for Highlighting text -- non tikz method
        \newcommand{\highlight}[2]{\colorbox{#1!17}{$\displaystyle #2$}}
        %\newcommand{\highlight}[2]{\colorbox{#1!17}{$#2$}}
        \newcommand{\highlightdark}[2]{\colorbox{#1!47}{$\displaystyle #2$}}
        
        % my custom colors for shading
        \colorlet{mhpurple}{Plum!80}
        
        
        % Commands for Highlighting text -- non tikz method
        \renewcommand{\highlight}[2]{\colorbox{#1!17}{#2}}
        \renewcommand{\highlightdark}[2]{\colorbox{#1!47}{#2}}
        
        % Some math definitions
        \newcommand{\lap}{\mathrm{Lap}}
        \newcommand{\pr}{\mathrm{Pr}}
        
        \newcommand{\Tset}{\mathcal{T}}
        \newcommand{\Dset}{\mathcal{D}}
        \newcommand{\Rbound}{\widetilde{\mathcal{R}}}

% >> ------------------ 文章宏包及相关设置 ------------------ << %
% ------------------------------------------------------------- %



% ----------------------------------------------------------- %
% >> --------------------- 文章信息区 --------------------- << %
% 页眉页脚设置

\usepackage{fancyhdr}   %宏包：页眉页脚设置
    \pagestyle{fancy}
    \fancyhf{}
    \cfoot{\thepage}
    \renewcommand\headrulewidth{1pt}
    \renewcommand\footrulewidth{0pt}
    \rhead{数据结构与算法期末复习,\ 尹超,\ 2023K8009926003}
    \lhead{Homework}


%文档信息设置
\title{数据结构与算法期末复习\\ Homework}
\author{尹超\\ \footnotesize 中国科学院大学，北京 100049\\ Carter Yin \\ \footnotesize University of Chinese Academy of Sciences, Beijing 100049, China}
\date{\footnotesize 2024.8 -- 2025.1}
% >> --------------------- 文章信息区 --------------------- << %
% ----------------------------------------------------------- %     


% 开始编辑文章

\begin{document}
\zihao{5}           % 设置全文字号大小

% --------------------------------------------------------------- %
% >> --------------------- 封面序言与目录 --------------------- << %
% 封面
    \maketitle\newpage  
    \pagenumbering{Roman} % 页码为大写罗马数字
    \thispagestyle{fancy}   % 显示页码、页眉等

% 序言
    \begin{cnabstract}\normalsize 
        本文为笔者数据结构与算法的期末复习笔记。\par
        望老师批评指正。
    \end{cnabstract}
    \addcontentsline{toc}{chapter}{序言} % 手动添加为目录

% % 不换页目录
%     \setcounter{tocdepth}{0}
%     \noindent\rule{\textwidth}{0.1em}   % 分割线
%     \noindent\begin{minipage}{\textwidth}\centering 
%         \vspace{1cm}
%         \tableofcontents\thispagestyle{fancy}   % 显示页码、页眉等   
%     \end{minipage}  
%     \addcontentsline{toc}{chapter}{目录} % 手动添加为目录

% 目录
\setcounter{tocdepth}{4}                % 目录深度（为1时显示到section）
\tableofcontents                        % 目录页
\addcontentsline{toc}{chapter}{目录}    % 手动添加此页为目录
\thispagestyle{fancy}                   % 显示页码、页眉等 

% 收尾工作
    \newpage    
    \pagenumbering{arabic} 

% >> --------------------- 封面序言与目录 --------------------- << %
% --------------------------------------------------------------- %

\chapter{第四章}

\section*{63}
\begin{graybox}
栈S初始为空，进行以下操作后从栈顶到栈底
的元素依次为：\\
S.push(5);\\
S.push(4);\\
S.pop();\\
S.push(2);\\
S.pop();\\
S.pop();\\
S.push(1) \\
A. 5, 4, 2, 1 \\
B. 1, 2, 4, 5 \\
C. 1 \\
D. 5, 4
\end{graybox}

\begin{solution}
正确答案是C。

\textbf{详细解答：}

我们一步步追踪栈S的状态。栈的特点是后进先出 (LIFO)。
我们将栈顶表示在列表的右侧。

\begin{enumerate}
    \item \textbf{初始状态：} S = [] (空栈)
    \item \textbf{S.push(5)：} 元素5入栈。
          S = [5]
          (栈底 -> 栈顶: 5)
    \item \textbf{S.push(4)：} 元素4入栈。
          S = [5, 4]
          (栈底 -> 栈顶: 5, 4)
    \item \textbf{S.pop()：} 栈顶元素4出栈。
          S = [5]
          (栈底 -> 栈顶: 5)
    \item \textbf{S.push(2)：} 元素2入栈。
          S = [5, 2]
          (栈底 -> 栈顶: 5, 2)
    \item \textbf{S.pop()：} 栈顶元素2出栈。
          S = [5]
          (栈底 -> 栈顶: 5)
    \item \textbf{S.pop()：} 栈顶元素5出栈。
          S = [] (空栈)
    \item \textbf{S.push(1)：} 元素1入栈。
          S = [1]
          (栈底 -> 栈顶: 1)
\end{enumerate}
操作完成后，栈S中只有一个元素1。
从栈顶到栈底的元素依次为：1。

因此，选项C是正确的。
\end{solution}


\section*{64}
\begin{graybox}
当扫描到一个左括号时：\\
A. 出栈 \\
B. 进栈 \\
C. 跳过该字符 \\
D. 算法结束
\end{graybox}

\begin{solution}
正确答案是B。

\textbf{详细解答：}

这个问题通常出现在处理算术表达式、括号匹配或类似的算法场景中，这些算法通常会使用栈来辅助操作。

当扫描到一个左括号 `(` 时，一般的处理规则是将其压入栈中。
\begin{itemize}
    \item \textbf{表达式求值/转换（如中缀转后缀）：} 左括号通常被压入栈，以标记一个子表达式的开始。它会停留在栈中，直到遇到对应的右括号。
    \item \textbf{括号匹配：} 左括号被压入栈。当遇到右括号时，会从栈顶弹出一个元素进行匹配。如果栈顶不是对应的左括号，则表示括号不匹配。
\end{itemize}

具体分析选项：
\begin{itemize}
    \item \textbf{A. 出栈：} 出栈操作通常与遇到右括号或操作符优先级处理相关，而不是左括号。
    \item \textbf{B. 进栈：} 这是处理左括号的标准操作。
    \item \textbf{C. 跳过该字符：} 跳过左括号会导致无法正确处理表达式的结构或括号的匹配关系。
    \item \textbf{D. 算法结束：} 扫描到左括号通常是算法处理过程的一部分，而不是结束的标志。
\end{itemize}

因此，当扫描到一个左括号时，正确的操作是将其进栈。
\end{solution}

\section*{65}
\begin{graybox}
{3,1,2,4}是否是{1,2,3,4}的栈混洗？\\
A. 是 \\
B. 不是
\end{graybox}

\begin{solution}
正确答案是 B (不是)。

\textbf{详细分析：}

我们要判断序列 $P = \{3,1,2,4\}$ 是否可以作为输入序列 $I = \{1,2,3,4\}$ 的一个栈混洗（也称为栈置换或出栈序列）。这意味着我们尝试使用一个栈，按照以下规则操作，从输入序列 $I$ 生成输出序列 $P$：
\begin{enumerate}
    \item 按顺序从输入序列 $I$ 中取出元素。
    \item 取出的元素可以被压入栈中。
    \item 栈顶的元素可以被弹出，并作为输出序列 $P$ 的下一个元素。
\end{enumerate}

我们来模拟这个过程，尝试生成序列 $P = \{3,1,2,4\}$：

设栈为 $S$。
输入序列 $I = (1, 2, 3, 4)$。
目标输出序列 $P = (3, 1, 2, 4)$。

\begin{enumerate}
    \item \textbf{期望输出 $P_1 = 3$}：
    \begin{itemize}
        \item 从 $I$ 中取出 1，压入 $S$。 $S = [1]$ (栈底在左，栈顶在右)
        \item 从 $I$ 中取出 2，压入 $S$。 $S = [1, 2]$
        \item 从 $I$ 中取出 3，压入 $S$。 $S = [1, 2, 3]$
        \item 栈顶元素是 3，与 $P_1$ 匹配。从 $S$ 弹出 3。
              \quad 输出的第一个元素是 3。
              \quad $S = [1, 2]$
    \end{itemize}

    \item \textbf{期望输出 $P_2 = 1$}：
    \begin{itemize}
        \item 当前栈 $S = [1, 2]$。栈顶元素是 2。
        \item 我们期望输出的下一个元素是 1。
        \item 由于栈顶是 2 (不等于 1)，我们不能直接弹出 1。
        \item 输入序列 $I$ 中还剩下元素 4。如果我们将 4 压入栈，$S$ 变为 $[1, 2, 4]$，栈顶是 4，仍然不是 1。
        \item 元素 1 确实在栈中，但它在元素 2 的下方。要使元素 1 出栈，必须先将元素 2 从栈中弹出。
        \item 如果我们此时弹出元素 2，那么输出序列将变为 $(3, 2, \ldots)$。
        \item 这与目标输出序列 $(3, 1, \ldots)$ 的第二个元素不符。
    \end{itemize}
\end{enumerate}

由于在生成第一个元素 3 之后，无法在不违反栈操作规则（即必须先弹出栈顶元素）的情况下使得下一个输出元素为 1，因此序列 $\{3,1,2,4\}$ 不可能是序列 $\{1,2,3,4\}$ 的栈混洗。

另一种判断方法是检查是否存在一个“禁止模式”。对于输入序列 $1, 2, \ldots, n$，如果输出序列中存在三个元素 $x, y, z$（它们在输入序列中的原始顺序是 $x < y < z$），并且它们在输出序列中出现的顺序是 $z \ldots x \ldots y$（即 $z$ 先出现，然后是 $x$，然后是 $y$），那么这个输出序列不可能是合法的栈混洗。
在我们的例子中：
输入序列是 $(1,2,3,4)$。
输出序列是 $(3,1,2,4)$。
考虑元素 $x=1, y=2, z=3$。
它们在输入序列中的顺序是 $1 \rightarrow 2 \rightarrow 3$。
它们在输出序列 $(3,1,2,4)$ 中的顺序是 $3$ (在位置1)，然后是 $1$ (在位置2)，然后是 $2$ (在位置3)。这形成了 $z \ldots x \ldots y$ 的模式。
因此，这也不是一个合法的栈混洗。

\end{solution}


\section*{66}
\begin{graybox}
长度为4的序列共有多少个不同的栈混洗？
% A. ... % Options would go here if provided
% B. ...
% C. ...
% D. ...
\end{graybox}

\begin{solution}
\textbf{答案：14}

\textbf{详细解答：}

对于一个长度为 $n$ 的输入序列（例如 $\{1, 2, \ldots, n\}$），其所有可能的不同栈混洗（出栈序列）的数量由第 $n$ 个卡特兰数 (Catalan number) 给出，记为 $C_n$。

卡特兰数的计算公式为：
$$C_n = \frac{1}{n+1} \binom{2n}{n} = \frac{(2n)!}{(n+1)!n!}$$

在本题中，序列的长度为 $n=4$。我们需要计算 $C_4$：
$$C_4 = \frac{1}{4+1} \binom{2 \times 4}{4} = \frac{1}{5} \binom{8}{4}$$

首先，计算组合数 $\binom{8}{4}$：
$$ \binom{8}{4} = \frac{8!}{4!(8-4)!} = \frac{8!}{4!4!} $$
$$ \binom{8}{4} = \frac{8 \times 7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1}{(4 \times 3 \times 2 \times 1)(4 \times 3 \times 2 \times 1)} $$
$$ \binom{8}{4} = \frac{8 \times 7 \times 6 \times 5}{4 \times 3 \times 2 \times 1} = \frac{1680}{24} = 70 $$

然后，将 $\binom{8}{4} = 70$ 代入 $C_4$ 的公式：
$$ C_4 = \frac{1}{5} \times 70 = 14 $$

因此，长度为 4 的序列共有 14 个不同的栈混洗。

卡特兰数的前几项为：
$C_0 = 1$
$C_1 = 1$
$C_2 = 2$ (对于序列 {1,2}，栈混洗有 {1,2} 和 {2,1})
$C_3 = 5$ (对于序列 {1,2,3}，栈混洗有 {1,2,3}, {1,3,2}, {2,1,3}, {2,3,1}, {3,2,1})
$C_4 = 14$

\end{solution}



\section*{67}
\begin{graybox}
利用栈结构进行中缀表达式求值，什么时候进
行实际的运算？\\
A. 每遇到一个新的操作数 \\
B. 每遇到一个新的操作符 \\
C. 当前的操作符比栈顶的操作符优先级高 \\
D. 当前的操作符比栈顶的操作符优先级低
\end{graybox}

\begin{solution}
正确答案是 D。

\textbf{详细解答：}

在利用栈结构进行中缀表达式求值的典型算法中（通常使用两个栈：一个操作数栈，一个操作符栈），实际的运算（如加减乘除）通常在以下情况下发生：

\begin{enumerate}
    \item \textbf{当遇到的当前操作符的优先级低于或等于栈顶操作符的优先级时（对于左结合操作符）：}
    在这种情况下，栈顶的操作符具有更高或相等的优先级，意味着它应该先被计算。因此，从操作符栈中弹出栈顶操作符，从操作数栈中弹出相应的操作数，执行运算，并将结果压回操作数栈。这个过程会持续进行，直到栈顶操作符的优先级低于当前操作符，或者栈为空，或者栈顶是左括号。

    \item \textbf{当遇到右括号 `)` 时：}
    右括号表示一个子表达式的结束。此时，应不断从操作符栈中弹出操作符并执行运算，直到遇到匹配的左括号 `(` 为止。左括号随后也从栈中弹出。

    \item \textbf{当整个表达式扫描完毕时：}
    如果操作符栈中仍然有操作符，应依次弹出并执行运算，直到操作符栈为空。
\end{enumerate}

现在我们分析给出的选项：
\begin{itemize}
    \item \textbf{A. 每遇到一个新的操作数：} 遇到操作数时，通常是将其压入操作数栈，不直接进行运算。
    \item \textbf{B. 每遇到一个新的操作符：} 遇到新的操作符时，需要根据其与栈顶操作符的优先级关系来决定是将其压栈还是先执行栈顶的运算。并非每次都立即运算。
    \item \textbf{C. 当前的操作符比栈顶的操作符优先级高：} 如果当前操作符的优先级高于栈顶操作符，那么当前操作符应该被压入操作符栈，等待其操作数。此时不会执行栈顶的运算。例如，在 `2 + 3 * 4` 中，遇到 `*` 时，其优先级高于栈顶的 `+`，所以 `*` 被压栈。
    \item \textbf{D. 当前的操作符比栈顶的操作符优先级低：} 如果当前操作符的优先级低于栈顶操作符，这意味着栈顶的操作符（及其操作数）应该先进行计算。例如，在 `2 * 3 + 4` 中，遇到 `+` 时，其优先级低于栈顶的 `*`，所以先计算 `2 * 3`。这是进行实际运算的一个关键时机。
\end{itemize}

虽然更完整的条件是“当前操作符优先级低于或等于栈顶操作符优先级（对左结合操作符）”，但在给出的选项中，选项 D 描述了一个明确会触发运算的场景。当栈顶操作符的优先级确实高于当前扫描到的操作符时，栈顶的运算必须先执行。

因此，选项 D 是最合适的答案。
\end{solution}

\section*{68}
\begin{graybox}
利用栈结构进行逆波兰表达式的求值算法
中，什么时候进行一次实际的运算？\\
A. 每遇到一个新的操作数 \\
B. 每遇到一个新的操作符 \\
C. 当前操作符优先级高于栈顶 \\
D. 当前操作符优先级低于栈顶
\end{graybox}

\begin{solution}
正确答案是 B。

\textbf{详细解答：}

逆波兰表达式（Reverse Polish Notation, RPN），也称为后缀表达式，其求值算法通常使用一个栈。算法步骤如下：
\begin{enumerate}
    \item 从左到右扫描逆波兰表达式。
    \item 如果扫描到的是一个操作数，则将其压入栈中。
    \item 如果扫描到的是一个操作符，则从栈中弹出所需数量的操作数（对于二元操作符，通常是两个），执行该操作符所代表的运算，然后将运算结果压回栈中。
\end{enumerate}
当整个表达式扫描完毕后，栈中唯一剩下的元素就是表达式的最终结果。

根据这个算法：
\begin{itemize}
    \item \textbf{A. 每遇到一个新的操作数：} 当遇到操作数时，它被压入栈，不进行运算。
    \item \textbf{B. 每遇到一个新的操作符：} 当遇到操作符时，会从栈中取出操作数，并执行该操作符指定的运算。这是进行实际运算的时机。
    \item \textbf{C. 当前操作符优先级高于栈顶：} 逆波兰表达式的求值不涉及操作符优先级的比较。操作符按其出现的顺序直接应用于栈顶的操作数。
    \item \textbf{D. 当前操作符优先级低于栈顶：} 同上，操作符优先级在逆波兰表达式求值过程中不起作用。
\end{itemize}

因此，在利用栈结构进行逆波兰表达式求值的算法中，每当遇到一个新的操作符时，就会进行一次实际的运算。
\end{solution}


\section*{69}
\begin{graybox}
思考一下如何将逆波兰表达式还原为中缀表达
式呢？试将下列逆波兰表达式还原为中缀表达式：\\
$1 2 + 3 4 \textasciicircum * $ \\
A. (1-2)*3\textasciicircum4 \\
B. (1+2)*3\textasciicircum4 \\
C. (1+2)\textasciicircum3*4 \\
D. (1+3)*2\textasciicircum4
\end{graybox}

\begin{solution}
正确答案是 B。

\textbf{思考与转换方法：}

将逆波兰表达式（后缀表达式）转换为中缀表达式，通常也使用栈结构。算法步骤如下：
\begin{enumerate}
    \item 初始化一个空栈。
    \item 从左到右扫描逆波兰表达式的每一个元素（操作数或操作符）。
    \item \textbf{如果当前元素是操作数：} 将其压入栈中。
    \item \textbf{如果当前元素是操作符：}
        \begin{enumerate}
            \item 从栈中弹出栈顶元素，作为右操作数（operand2）。
            \item 再次从栈中弹出栈顶元素，作为左操作数（operand1）。
            \item 构建一个新的字符串，形式为 ``(operand1 操作符 operand2)''。注意，为了保证运算顺序的正确性，通常需要在子表达式两侧加上括号。
            \item 将这个新构建的子表达式字符串压回栈中。
        \end{enumerate}
    \item 当整个逆波兰表达式扫描完毕后，栈中应该只剩下一个元素，这个元素就是转换后的中缀表达式。
\end{enumerate}

\textbf{对给定表达式进行转换：}
逆波兰表达式为: \texttt{1 2 + 3 4 \textasciicircum\ *}

栈的状态变化如下（栈顶在右侧）：
\begin{enumerate}
    \item 扫描到 \textbf{1} (操作数):
          栈: `["1"]`
    \item 扫描到 \textbf{2} (操作数):
          栈: `["1", "2"]`
    \item 扫描到 \textbf{+} (操作符):
        \begin{itemize}
            \item 弹出 "2" (作为 operand2)
            \item 弹出 "1" (作为 operand1)
            \item 构建子表达式: `(1 + 2)`
            \item 压栈: `["(1+2)"]`
        \end{itemize}
          栈: `["(1+2)"]`
    \item 扫描到 \textbf{3} (操作数):
          栈: `["(1+2)", "3"]`
    \item 扫描到 \textbf{4} (操作数):
          栈: `["(1+2)", "3", "4"]`
    \item 扫描到 \textbf{\textasciicircum} (操作符, 代表乘方):
        \begin{itemize}
            \item 弹出 "4" (作为 operand2)
            \item 弹出 "3" (作为 operand1)
            \item 构建子表达式: `(3 \textasciicircum 4)`
            \item 压栈: `["(1+2)", "(3\textasciicircum4)"]`
        \end{itemize}
          栈: `["(1+2)", "(3\textasciicircum4)"]`
    \item 扫描到 \textbf{*} (操作符):
        \begin{itemize}
            \item 弹出 "(3\textasciicircum4)" (作为 operand2)
            \item 弹出 "(1+2)" (作为 operand1)
            \item 构建子表达式: `((1+2) * (3\textasciicircum4))`
            \item 压栈: `["((1+2)*(3\textasciicircum4))"]`
        \end{itemize}
          栈: `["((1+2)*(3\textasciicircum4))"]`
\end{enumerate}

表达式扫描完毕，栈中剩下的元素是 `((1+2)*(3\textasciicircum4))`。
这个表达式可以简化书写为 `(1+2)*3\textasciicircum4`，因为乘方 `\textasciicircum` 的优先级通常高于乘法 `*`，所以 `(3\textasciicircum4)` 外的括号可以省略，而 `(1+2)` 的括号是必需的，以确保加法先于乘法执行。

对照选项：
A. (1-2)*3\textasciicircum4  (错误的操作符 '-')
B. (1+2)*3\textasciicircum4  (匹配)
C. (1+2)\textasciicircum3*4  (运算顺序和操作数错误)
D. (1+3)*2\textasciicircum4  (操作数错误)

因此，还原后的中缀表达式是 (1+2)*3\textasciicircum4。
\end{solution}



\section*{70}
\begin{graybox}
栈初始为空，依次经过以下操作：\\
push(5);\\
push(8);\\
pop();\\
push(5);\\
top();\\
push(1);\\
push(3);\\
pop();\\
pop();\\
push(2);\\
此时从栈顶到栈底依次为：\\
A. 2, 5, 5 \\
B. 2, 3, 1 \\
C. 5, 5, 2 \\
D. 1, 3, 2
\end{graybox}

\begin{solution}
正确答案是 A。

\textbf{详细解答：}

我们一步步追踪栈S的状态。栈的特点是后进先出 (LIFO)。
我们将栈顶表示在列表的右侧（或者说，新元素加在右边，从右边弹出）。
\begin{enumerate}
    \item \textbf{初始状态：} S = [] (空栈)
    \item \textbf{push(5)：} 元素5入栈。
          S = [5]
          (栈底 $\rightarrow$ 栈顶: 5)
    \item \textbf{push(8)：} 元素8入栈。
          S = [5, 8]
          (栈底 $\rightarrow$ 栈顶: 5, 8)
    \item \textbf{pop()：} 栈顶元素8出栈。
          S = [5]
          (栈底 $\rightarrow$ 栈顶: 5)
    \item \textbf{push(5)：} 元素5入栈。
          S = [5, 5]
          (栈底 $\rightarrow$ 栈顶: 5, 5)
    \item \textbf{top()：} 查看栈顶元素。栈顶元素是5。栈状态不变。
          S = [5, 5]
          (栈底 $\rightarrow$ 栈顶: 5, 5)
    \item \textbf{push(1)：} 元素1入栈。
          S = [5, 5, 1]
          (栈底 $\rightarrow$ 栈顶: 5, 5, 1)
    \item \textbf{push(3)：} 元素3入栈。
          S = [5, 5, 1, 3]
          (栈底 $\rightarrow$ 栈顶: 5, 5, 1, 3)
    \item \textbf{pop()：} 栈顶元素3出栈。
          S = [5, 5, 1]
          (栈底 $\rightarrow$ 栈顶: 5, 5, 1)
    \item \textbf{pop()：} 栈顶元素1出栈。
          S = [5, 5]
          (栈底 $\rightarrow$ 栈顶: 5, 5)
    \item \textbf{push(2)：} 元素2入栈。
          S = [5, 5, 2]
          (栈底 $\rightarrow$ 栈顶: 5, 5, 2)
\end{enumerate}

操作完成后，栈S中的元素，如果按照从栈底到栈顶的顺序是 [5, 5, 2]。
题目要求“从栈顶到栈底依次为”，所以顺序应该是：2, 5, 5。

因此，选项A是正确的。
\end{solution}



\section*{71}
\begin{graybox}
阅读下面函数(其中1≤x, y≤16)，指出其功能：
\begin{lstlisting}
char digits[]={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
void convert(int y,int x){
    if(x!=0){
        convert(y,x/y);
        printf("%c",digits[x%y]);
    }
}
\end{lstlisting}
A. 打印十进制整数x的y进制表示 \\
B. 打印x进制整数100的y进制表示 \\
C. 打印十进制整数y的x进制表示 \\
D. 打印y进制整数100的x进制表示
\end{graybox}

\begin{solution}
正确答案是 A。

\textbf{详细分析：}

该函数 \texttt{convert(int y, int x)} 是一个递归函数，用于将一个整数转换为特定进制的表示形式。
\begin{itemize}
    \item \texttt{digits[]} 数组存储了0-15对应的字符表示，用于输出0-9和a-f（对应十六进制）。
    \item 函数参数 \texttt{y} 代表目标进制的基数。
    \item 函数参数 \texttt{x} 代表要转换的十进制整数。
    \item 递归的终止条件是 \texttt{x == 0}。
    \item 在递归步骤中：
        \begin{enumerate}
            \item \texttt{convert(y, x/y)}: 递归调用自身，处理整数 \texttt{x} 除以基数 \texttt{y} 的商。这相当于处理更高位的数字。
            \item \texttt{printf("\%c", digits[x\%y])}: 在递归调用返回后，打印整数 \texttt{x} 对基数 \texttt{y} 取余的结果所对应的字符。这个余数是当前最低位的数字。
        \end{enumerate}
\end{itemize}
由于 \texttt{printf} 语句在递归调用之后执行，这意味着数字是按照从高位到低位的顺序生成的（因为最深的递归对应最高位，它最先完成其 \texttt{printf} 之前的递归调用，然后当递归逐层返回时，较低位的数字被打印出来）。


举例说明：假设调用 \texttt{convert(2, 10)}，即把十进制数10转换为2进制。
\begin{enumerate}
    \item \texttt{convert(2, 10)}: $10 \neq 0$
    \begin{itemize}
        \item 调用 \texttt{convert(2, 10/2)} 即 \texttt{convert(2, 5)}
        \item \texttt{convert(2, 5)}: $5 \neq 0$
        \begin{itemize}
            \item 调用 \texttt{convert(2, 5/2)} 即 \texttt{convert(2, 2)}
            \item \texttt{convert(2, 2)}: $2 \neq 0$
            \begin{itemize}
                \item 调用 \texttt{convert(2, 2/2)} 即 \texttt{convert(2, 1)}
                \item \texttt{convert(2, 1)}: $1 \neq 0$
                \begin{itemize}
                    \item 调用 \texttt{convert(2, 1/2)} 即 \texttt{convert(2, 0)}
                    \item \texttt{convert(2, 0)}: $0 == 0$，函数返回。
                    \item (从 \texttt{convert(2,1)} 返回后) 打印 \texttt{digits[1\%2]} 即 \texttt{digits[1]} ('1')。
                \end{itemize}
                \item (从 \texttt{convert(2,2)} 返回后) 打印 \texttt{digits[2\%2]} 即 \texttt{digits[0]} ('0')。
            \end{itemize}
            \item (从 \texttt{convert(2,5)} 返回后) 打印 \texttt{digits[5\%2]} 即 \texttt{digits[1]} ('1')。
        \end{itemize}
        \item (从 \texttt{convert(2,10)} 返回后) 打印 \texttt{digits[10\%2]} 即 \texttt{digits[0]} ('0')。
    \end{itemize}
\end{enumerate}
输出顺序将是 '1', '0', '1', '0'，即 "1010"，这是十进制数10的二进制表示。

因此，函数的功能是打印十进制整数 \texttt{x} 的 \texttt{y} 进制表示。
这与选项 A "打印十进制整数x的y进制表示" 相符。
\end{solution}




\section*{72}
\begin{graybox}
对序列{2, 3, 5, 7, 11}进行栈混洗得
到{3, 5, 2, 11, 7}的过程中用于中转的栈
S进行的操作是:\\
A. push, pop, pop, push, push, pop, push, push, pop, pop \\
B. push, push, pop, pop, pop, pop, push, push, push, pop \\
C. push, push, pop, push, pop, pop, push, pop, pop, pop \\
D. push, push, pop, push, pop, pop, push, push pop, pop
\end{graybox}

\begin{solution}
正确答案是 D。
(选项D中 "push, push pop, pop" 应理解为 "push, push, pop, pop")

\textbf{详细分析：}

设输入序列为 $I = \{2, 3, 5, 7, 11\}$，目标输出序列为 $O = \{3, 5, 2, 11, 7\}$。
我们使用一个栈 $S$ 来模拟这个过程。栈顶在右侧。

\begin{enumerate}
    \item \textbf{目标输出 $O_1 = 3$}:
    \begin{itemize}
        \item 从 $I$ 取出 2，执行 \texttt{push(2)}。 $S = [2]$。操作序列: \texttt{push}
        \item 从 $I$ 取出 3，执行 \texttt{push(3)}。 $S = [2, 3]$。操作序列: \texttt{push, push}
        \item 栈顶元素 3 与 $O_1$ 匹配。执行 \texttt{pop()}。输出 3。 $S = [2]$。操作序列: \texttt{push, push, pop}
    \end{itemize}

    \item \textbf{目标输出 $O_2 = 5$}:
    \begin{itemize}
        \item 栈顶元素 2 不等于 $O_2=5$。
        \item 从 $I$ 取出 5，执行 \texttt{push(5)}。 $S = [2, 5]$。操作序列: \texttt{push, push, pop, push}
        \item 栈顶元素 5 与 $O_2$ 匹配。执行 \texttt{pop()}。输出 5。 $S = [2]$。操作序列: \texttt{push, push, pop, push, pop}
    \end{itemize}

    \item \textbf{目标输出 $O_3 = 2$}:
    \begin{itemize}
        \item 栈顶元素 2 与 $O_3$ 匹配。执行 \texttt{pop()}。输出 2。 $S = []$ (空栈)。操作序列: \texttt{push, push, pop, push, pop, pop}
    \end{itemize}

    \item \textbf{目标输出 $O_4 = 11$}:
    \begin{itemize}
        \item 栈为空。
        \item 从 $I$ 取出 7，执行 \texttt{push(7)}。 $S = [7]$。操作序列: \texttt{push, push, pop, push, pop, pop, push}
        \item 栈顶元素 7 不等于 $O_4=11$。
        \item 从 $I$ 取出 11，执行 \texttt{push(11)}。 $S = [7, 11]$。操作序列: \texttt{push, push, pop, push, pop, pop, push, push}
        \item 栈顶元素 11 与 $O_4$ 匹配。执行 \texttt{pop()}。输出 11。 $S = [7]$。操作序列: \texttt{push, push, pop, push, pop, pop, push, push, pop}
    \end{itemize}

    \item \textbf{目标输出 $O_5 = 7$}:
    \begin{itemize}
        \item 栈顶元素 7 与 $O_5$ 匹配。执行 \texttt{pop()}。输出 7。 $S = []$ (空栈)。操作序列: \texttt{push, push, pop, push, pop, pop, push, push, pop, pop}
    \end{itemize}
\end{enumerate}

最终的操作序列为: \texttt{push, push, pop, push, pop, pop, push, push, pop, pop}。
这与选项 D (在修正了可能的打印错误后) 相符。

\end{solution}


\section*{73}
\begin{graybox}
{1,2,3... i...j...k...n}:下列哪一个序
列一定不是{1,2,3… i…j…k…n}的栈混洗：\\
A. {… i…j…k…} \\
B. {… k…j…i…} \\
C. {… k…i…j…} \\
D. {… j…k…i…}
\end{graybox}

\begin{solution}
正确答案是 C。

\textbf{详细分析：}

一个序列 $P$ 不是输入序列 $I$ 的栈混洗，有一个著名的判断条件（禁忌模式）：
如果输入序列 $I$ 中有三个元素 $x, y, z$ 依次出现（即 $x$ 在 $y$ 之前， $y$ 在 $z$ 之前），那么在任何合法的栈混洗输出序列 $P$ 中，不可能出现 $z$ 先输出，然后 $x$ 输出，最后 $y$ 输出的相对顺序。也就是说，子序列 $z \ldots x \ldots y$ 是被禁止的。

在题目中，输入序列是 $\{1, 2, 3, \ldots, i, \ldots, j, \ldots, k, \ldots, n\}$。这意味着元素 $i, j, k$ 在输入流中出现的顺序是 $i \rightarrow j \rightarrow k$。

根据上述禁忌模式，令 $x=i, y=j, z=k$。
那么，任何包含 $k \ldots i \ldots j$ 作为子序列（保持此相对顺序）的输出序列，一定不是一个合法的栈混洗。

我们来分析各个选项中 $i, j, k$ 的相对顺序：
\begin{itemize}
    \item \textbf{A. {… i…j…k…}}
        相对顺序是 $i \rightarrow j \rightarrow k$。
        这是可能的。例如：依次将 $i, j, k$ 入栈并立即出栈。
        (push $i$, pop $i$; push $j$, pop $j$; push $k$, pop $k$)

    \item \textbf{B. {… k…j…i…}}
        相对顺序是 $k \rightarrow j \rightarrow i$。
        这是可能的。例如：依次将 $i, j, k$ 入栈，然后依次出栈。
        (push $i$, push $j$, push $k$; pop $k$, pop $j$, pop $i$)

    \item \textbf{C. {… k…i…j…}}
        相对顺序是 $k \rightarrow i \rightarrow j$。
        这符合我们上面讨论的禁忌模式 $z \ldots x \ldots y$（其中 $x=i, y=j, z=k$）。
        为了更具体地理解为什么这是不可能的：
        \begin{enumerate}
            \item 要想首先输出 $k$，元素 $i, j, k$ 必须都已经被压入栈中（或者 $i,j$ 在栈中，$k$ 刚被压入并立即弹出）。假设 $i, j, k$ 都已按顺序入栈，栈的状态（从底到顶）为 $[\ldots, i, j, k]$。
            \item 此时 $k$ 出栈。输出序列得到 $k$。栈变为 $[\ldots, i, j]$。
            \item 接下来，我们希望输出 $i$。但是，元素 $j$ 在栈中位于 $i$ 的上方。根据栈的 LIFO 原则，必须先将 $j$ 弹出，然后才能弹出 $i$。
            \item 如果 $j$ 先弹出，那么输出序列就会变成 $k \ldots j \ldots$，而不是期望的 $k \ldots i \ldots$。
        \end{enumerate}
        因此，序列 ${… k…i…j…}$ 一定不是合法的栈混洗。

    \item \textbf{D. {… j…k…i…}}
        相对顺序是 $j \rightarrow k \rightarrow i$。
        这是可能的。例如：
        (push $i$; push $j$; pop $j$; push $k$; pop $k$; pop $i$)
        这样得到的输出子序列是 $j, k, i$。
\end{itemize}

综上所述，序列 {… k…i…j…} 一定不是给定输入序列的栈混洗。
\end{solution}



\section*{74}
\begin{graybox}
以下几个量中相等的是:\\
1 不同的n位二进制数个数 \\
2 对小括号所能构成的合法括号匹配个数 \\
3 {1, 2 .. n}的不同栈混洗个数 \\
4 含n个运算符的中缀表达式求值过程中运算符栈push操作的次数 \\
A. 12 \\
B. 23 \\
C. 34 \\
D. 24
\end{graybox}

\begin{solution}
正确答案是 B。

\textbf{详细分析：}
我们逐个分析这四个量，假设 $n$ 是一个正整数。

\begin{enumerate}
    \item[\textbf{1}] \textbf{不同的n位二进制数个数：}
        一个n位的二进制数，每一位都有2种选择（0或1）。因此，总共有 $2 \times 2 \times \ldots \times 2$ (n次) = $2^n$ 个不同的n位二进制数。

    \item[\textbf{2}] \textbf{对小括号所能构成的合法括号匹配个数：}
        这指的是用n对小括号（即n个左括号和n个右括号）可以形成的合法匹配序列的数量。这个数量由第n个卡特兰数 $C_n$ 给出。
        $C_n = \frac{1}{n+1}\binom{2n}{n}$。

    \item[\textbf{3}] \textbf{{1, 2 .. n}的不同栈混洗个数：}
        一个包含n个不同元素的序列（如 {1, 2, ..., n}）通过一个栈进行操作，所有可能的出栈序列（栈混洗）的数量也是由第n个卡特兰数 $C_n$ 给出。

    \item[\textbf{4}] \textbf{含n个运算符的中缀表达式求值过程中运算符栈push操作的次数：}
        在标准的中缀表达式求值算法中（例如使用迪克斯特拉的双栈算法或改进版），表达式中的每一个运算符最终都会被压入操作符栈一次。如果一个中缀表达式含有n个运算符，那么这n个运算符中的每一个都会被执行一次push操作到操作符栈。因此，这个次数是 $n$。
        （注意：左括号也会被压入操作符栈，但题目关注的是由n个运算符引起的push次数，或者说，如果只考虑运算符本身的push，则是n次）。
\end{enumerate}

总结各个量：
\begin{itemize}
    \item 量1 = $2^n$
    \item 量2 = $C_n$
    \item 量3 = $C_n$
    \item 量4 = $n$
\end{itemize}

比较这些量，我们可以看到量2和量3都等于第n个卡特兰数 $C_n$，因此它们是相等的。

\begin{itemize}
    \item $2^n$ 通常不等于 $C_n$ (例如, $n=3$, $2^3=8$, $C_3=5$)。
    \item $C_n$ 通常不等于 $n$ (例如, $n=3$, $C_3=5$, $n=3$; 它们仅在 $n=1$ 和 $n=2$ 时碰巧相等)。
\end{itemize}

因此，只有量2和量3是普遍相等的。
所以选项B (23) 是正确的。
\end{solution}




\section*{75}
\begin{graybox}
在中缀表达式求值中，某时刻运算数栈从栈顶
到栈底依次为:
6，2，1
运算符栈从栈顶到栈底依次为:
x, +, (
剩下的待处理表达式为:
)/(4 × 5 – 7)
在接下来的过程中运算符的入栈顺序以及最终的计
算结果分别为：\\
A. /(x-最终结果为8 \\
B. /(x- ) 最终结果为8 \\
C. /(x-最终结果为1 \\
D. /(x-)最终结果为1
\end{graybox}

\begin{solution}
正确答案是 C。

\textbf{详细分析：}

假设题目中的 `x` 代表乘法运算符 `*`。
初始状态：
\begin{itemize}
    \item 运算数栈 (S\_num)，从栈底到栈顶: `[1, 2, 6]` (栈顶是 6)
    \item 运算符栈 (S\_op)，从栈底到栈顶: `[(, +, *]` (栈顶是 `*`)
    \item 待处理表达式 (Rem): `)/(4 * 5 – 7)`
\end{itemize}

追踪步骤：
\begin{enumerate}
    \item 读取 Rem 的第一个字符: `)`.
    \begin{itemize}
        \item 遇到右括号，处理 S\_op 直到 `(`.
        \item Pop `*` from S\_op. Pop `6`, `2` from S\_num. $2 * 6 = 12$. Push `12` to S\_num. S\_num: `[1, 12]`. S\_op: `[(, +]`.
        \item Pop `+` from S\_op. Pop `12`, `1` from S\_num. $1 + 12 = 13$. Push `13` to S\_num. S\_num: `[13]`. S\_op: `[(]`.
        \item Pop `(` from S\_op. S\_op: `[]`.
    \end{itemize}
    此时，"接下来的过程"中被推入运算符栈的运算符序列 (PushedOps) 为空。Rem 变为 `/(4 * 5 – 7)`.

    \item 读取 Rem 的 `/`. Push `/` to S\_op. S\_op: `[/]`. PushedOps: `[/]`.
    \item 读取 Rem 的 `(`. Push `(` to S\_op. S\_op: `[/, (]`. PushedOps: `[/, (]`.
    \item 读取 Rem 的 `4`. Push `4` to S\_num. S\_num: `[13, 4]`.
    \item 读取 Rem 的 `*` (即 `x`). S\_op 顶为 `(`. `*` 优先级高. Push `*` to S\_op. S\_op: `[/, (, *]`. PushedOps: `[/, (, *]`.
    \item 读取 Rem 的 `5`. Push `5` to S\_num. S\_num: `[13, 4, 5]`.
    \item 读取 Rem 的 `–`. S\_op 顶为 `*`. `–` 优先级低.
    \begin{itemize}
        \item Pop `*`. Pop `5`, `4`. $4 * 5 = 20$. Push `20` to S\_num. S\_num: `[13, 20]`. S\_op: `[/, (]`.
    \end{itemize}
    S\_op 顶为 `(`. `–` 优先级高. Push `–` to S\_op. S\_op: `[/, (, –]`. PushedOps: `[/, (, *, –]`.
    \item 读取 Rem 的 `7`. Push `7` to S\_num. S\_num: `[13, 20, 7]`.
    \item 读取 Rem 的 `)`.
    \begin{itemize}
        \item Pop `–`. Pop `7`, `20`. $20 – 7 = 13$. Push `13` to S\_num. S\_num: `[13, 13]`. S\_op: `[/, (]`.
        \item Pop `(`. S\_op: `[/]`.
    \end{itemize}
    \item Rem 为空. 处理 S\_op.
    \begin{itemize}
        \item Pop `/`. Pop `13`, `13`. $13 / 13 = 1$. Push `1` to S\_num. S\_num: `[1]`. S\_op: `[]`.
    \end{itemize}
\end{enumerate}

最终结果为 `1`.
"接下来的过程中运算符的入栈顺序" 为 `/, (, *, –` (即选项中的 `/(x-`，其中 `x` 为 `*`)。
这与选项 C " /(x-最终结果为1 " 相符。
\end{solution}


\section*{76}
\begin{graybox}
(1+2×3!)/(4×5-7)的逆波兰表达式为
(表达式中的整数都是一位数)
\end{graybox}

\begin{solution}
\textbf{逆波兰表达式 (后缀表达式) 为: \texttt{1 2 3 ! × + 4 5 × 7 - /}}

\textbf{详细转换步骤：}

我们将使用标准的运算符优先级（从高到低）：
\begin{enumerate}
    \item 阶乘 `!`
    \item 乘法 `×`，除法 `/` (同级，从左到右)
    \item 加法 `+`，减法 `-` (同级，从左到右)
    \item 括号 `()` 具有最高优先级，改变运算顺序。
\end{enumerate}

原中缀表达式为: \texttt{(1+2×3!)/(4×5-7)}

我们可以将其看作是 Numerator / Denominator 的形式。
Numerator (分子): \texttt{(1+2×3!)}
Denominator (分母): \texttt{(4×5-7)}

\textbf{1. 转换分子 \texttt{(1+2×3!)}}
\begin{itemize}
    \item 首先处理内部最高优先级的运算 `3!`。
        中缀: `3!`
        后缀: `3 !`
    \item 接下来是 `2×3!`，可以看作 `2 × (3!)`。
        中缀: `2 × 3!`
        后缀 (将 `3!` 的后缀代入): `2 (3 !) ×`  $\rightarrow$ \texttt{2 3 ! ×}
    \item 然后是 `1 + (2×3!)`。
        中缀: `1 + 2×3!`
        后缀 (将 `2×3!` 的后缀代入): `1 (2 3 ! ×) +` $\rightarrow$ \texttt{1 2 3 ! × +}
\end{itemize}
所以，分子的后缀表达式是: \texttt{1 2 3 ! × +}

\textbf{2. 转换分母 \texttt{(4×5-7)}}
\begin{itemize}
    \item 首先处理 `4×5`。
        中缀: `4×5`
        后缀: `4 5 ×`
    \item 然后是 `(4×5) - 7`。
        中缀: `4×5 - 7`
        后缀 (将 `4×5` 的后缀代入): `(4 5 ×) 7 -` $\rightarrow$ \texttt{4 5 × 7 -}
\end{itemize}
所以，分母的后缀表达式是: \texttt{4 5 × 7 -}

\textbf{3. 组合分子和分母}
原表达式是 Numerator / Denominator。
后缀形式为: (后缀 Numerator) (后缀 Denominator) /
代入已转换的后缀表达式：
\texttt{(1 2 3 ! × +) (4 5 × 7 -) /}
$\rightarrow$ \texttt{1 2 3 ! × + 4 5 × 7 - /}

\textbf{使用Shunting-yard算法（调度场算法）验证：}
输入: \texttt{( 1 + 2 × 3 ! ) / ( 4 × 5 - 7 )}
输出队列 (Q):
运算符栈 (S):

\begin{tabular}{llll}
Token & Action & Q & S \\
\hline
( & Push ( to S & & ( \\
1 & Add 1 to Q & 1 & ( \\
+ & Push + to S (S top is (, or lower prec) & 1 & ( + \\
2 & Add 2 to Q & 1 2 & ( + \\
× & Push × to S (prec(×) > prec(+)) & 1 2 & ( + × \\
3 & Add 3 to Q & 1 2 3 & ( + × \\
! & Push ! to S (prec(!) > prec(×)) & 1 2 3 & ( + × ! \\
) & Pop S to Q until ( found & & \\
  & Pop ! & 1 2 3 ! & ( + × \\
  & Pop × & 1 2 3 ! × & ( + \\
  & Pop + & 1 2 3 ! × + & ( \\
  & Pop ( & 1 2 3 ! × + & \\
/ & Push / to S & 1 2 3 ! × + & / \\
( & Push ( to S & 1 2 3 ! × + & / ( \\
4 & Add 4 to Q & 1 2 3 ! × + 4 & / ( \\
× & Push × to S (S top is (, or lower prec) & 1 2 3 ! × + 4 & / ( × \\
5 & Add 5 to Q & 1 2 3 ! × + 4 5 & / ( × \\
- & Pop S to Q (prec(-) $\le$ prec(×)) & & \\
  & Pop × & 1 2 3 ! × + 4 5 × & / ( \\
  & Push - to S (S top is (, or lower prec) & 1 2 3 ! × + 4 5 × & / ( - \\
7 & Add 7 to Q & 1 2 3 ! × + 4 5 × 7 & / ( - \\
) & Pop S to Q until ( found & & \\
  & Pop - & 1 2 3 ! × + 4 5 × 7 - & / ( \\
  & Pop ( & 1 2 3 ! × + 4 5 × 7 - & / \\
End & Pop all from S to Q & & \\
  & Pop / & \texttt{1 2 3 ! × + 4 5 × 7 - /} & \\
\hline
\end{tabular}

最终的逆波兰表达式为: \texttt{1 2 3 ! × + 4 5 × 7 - /}
\end{solution}













\end{document}

% VScode 常用快捷键：

% Ctrl + R:                 打开最近的文件夹
% F2:                       变量重命名
% Ctrl + Enter:             行中换行
% Alt + up/down:            上下移行
% 鼠标中键 + 移动:           快速多光标
% Shift + Alt + up/down:    上下复制
% Ctrl + left/right:        左右跳单词
% Ctrl + Backspace/Delete:  左右删单词    
% Shift + Delete:           删除此行
% Ctrl + J:                 打开 VScode 下栏(输出栏)
% Ctrl + B:                 打开 VScode 左栏(目录栏)
% Ctrl + `:                 打开 VScode 终端栏
% Ctrl + 0:                 定位文件
% Ctrl + Tab:               切换已打开的文件(切标签)
% Ctrl + Shift + P:         打开全局命令(设置)

% Latex 常用快捷键

% Ctrl + Alt + J:           由代码定位到PDF
% 


% Git提交规范：
% update: Linear Algebra 2 notes
% add: Linear Algebra 2 notes
% import: Linear Algebra 2 notes
% delete: Linear Algebra 2 notes
